{"filter":false,"title":"jquery-mobile.js","tooltip":"/components/scripts/jquery-mobile.js","undoManager":{"mark":0,"position":0,"stack":[[{"group":"doc","deltas":[{"start":{"row":0,"column":0},"end":{"row":863,"column":4},"action":"insert","lines":["/*","* jQuery Mobile v1.4.5","* http://jquerymobile.com","*","* Copyright 2010, 2014 jQuery Foundation, Inc. and other contributors","* Released under the MIT license.","* http://jquery.org/license","*","*/","","(function ( root, doc, factory ) {","\tif ( typeof define === \"function\" && define.amd ) {","\t\t// AMD. Register as an anonymous module.","\t\tdefine( [ \"jquery\" ], function ( $ ) {","\t\t\tfactory( $, root, doc );","\t\t\treturn $.mobile;","\t\t});","\t} else {","\t\t// Browser globals","\t\tfactory( root.jQuery, root, doc );","\t}","}( this, document, function ( jQuery, window, document, undefined ) {// This plugin is an experiment for abstracting away the touch and mouse","// events so that developers don't have to worry about which method of input","// the device their document is loaded on supports.","//","// The idea here is to allow the developer to register listeners for the","// basic mouse events, such as mousedown, mousemove, mouseup, and click,","// and the plugin will take care of registering the correct listeners","// behind the scenes to invoke the listener at the fastest possible time","// for that device, while still retaining the order of event firing in","// the traditional mouse environment, should multiple handlers be registered","// on the same element for different events.","//","// The current version exposes the following virtual events to jQuery bind methods:","// \"vmouseover vmousedown vmousemove vmouseup vclick vmouseout vmousecancel\"","","(function( $, window, document, undefined ) {","","var dataPropertyName = \"virtualMouseBindings\",","\ttouchTargetPropertyName = \"virtualTouchID\",","\tvirtualEventNames = \"vmouseover vmousedown vmousemove vmouseup vclick vmouseout vmousecancel\".split( \" \" ),","\ttouchEventProps = \"clientX clientY pageX pageY screenX screenY\".split( \" \" ),","\tmouseHookProps = $.event.mouseHooks ? $.event.mouseHooks.props : [],","\tmouseEventProps = $.event.props.concat( mouseHookProps ),","\tactiveDocHandlers = {},","\tresetTimerID = 0,","\tstartX = 0,","\tstartY = 0,","\tdidScroll = false,","\tclickBlockList = [],","\tblockMouseTriggers = false,","\tblockTouchTriggers = false,","\teventCaptureSupported = \"addEventListener\" in document,","\t$document = $( document ),","\tnextTouchID = 1,","\tlastTouchID = 0, threshold,","\ti;","","$.vmouse = {","\tmoveDistanceThreshold: 10,","\tclickDistanceThreshold: 10,","\tresetTimerDuration: 1500","};","","function getNativeEvent( event ) {","","\twhile ( event && typeof event.originalEvent !== \"undefined\" ) {","\t\tevent = event.originalEvent;","\t}","\treturn event;","}","","function createVirtualEvent( event, eventType ) {","","\tvar t = event.type,","\t\toe, props, ne, prop, ct, touch, i, j, len;","","\tevent = $.Event( event );","\tevent.type = eventType;","","\toe = event.originalEvent;","\tprops = $.event.props;","","\t// addresses separation of $.event.props in to $.event.mouseHook.props and Issue 3280","\t// https://github.com/jquery/jquery-mobile/issues/3280","\tif ( t.search( /^(mouse|click)/ ) > -1 ) {","\t\tprops = mouseEventProps;","\t}","","\t// copy original event properties over to the new event","\t// this would happen if we could call $.event.fix instead of $.Event","\t// but we don't have a way to force an event to be fixed multiple times","\tif ( oe ) {","\t\tfor ( i = props.length, prop; i; ) {","\t\t\tprop = props[ --i ];","\t\t\tevent[ prop ] = oe[ prop ];","\t\t}","\t}","","\t// make sure that if the mouse and click virtual events are generated","\t// without a .which one is defined","\tif ( t.search(/mouse(down|up)|click/) > -1 && !event.which ) {","\t\tevent.which = 1;","\t}","","\tif ( t.search(/^touch/) !== -1 ) {","\t\tne = getNativeEvent( oe );","\t\tt = ne.touches;","\t\tct = ne.changedTouches;","\t\ttouch = ( t && t.length ) ? t[0] : ( ( ct && ct.length ) ? ct[ 0 ] : undefined );","","\t\tif ( touch ) {","\t\t\tfor ( j = 0, len = touchEventProps.length; j < len; j++) {","\t\t\t\tprop = touchEventProps[ j ];","\t\t\t\tevent[ prop ] = touch[ prop ];","\t\t\t}","\t\t}","\t}","","\treturn event;","}","","function getVirtualBindingFlags( element ) {","","\tvar flags = {},","\t\tb, k;","","\twhile ( element ) {","","\t\tb = $.data( element, dataPropertyName );","","\t\tfor (  k in b ) {","\t\t\tif ( b[ k ] ) {","\t\t\t\tflags[ k ] = flags.hasVirtualBinding = true;","\t\t\t}","\t\t}","\t\telement = element.parentNode;","\t}","\treturn flags;","}","","function getClosestElementWithVirtualBinding( element, eventType ) {","\tvar b;","\twhile ( element ) {","","\t\tb = $.data( element, dataPropertyName );","","\t\tif ( b && ( !eventType || b[ eventType ] ) ) {","\t\t\treturn element;","\t\t}","\t\telement = element.parentNode;","\t}","\treturn null;","}","","function enableTouchBindings() {","\tblockTouchTriggers = false;","}","","function disableTouchBindings() {","\tblockTouchTriggers = true;","}","","function enableMouseBindings() {","\tlastTouchID = 0;","\tclickBlockList.length = 0;","\tblockMouseTriggers = false;","","\t// When mouse bindings are enabled, our","\t// touch bindings are disabled.","\tdisableTouchBindings();","}","","function disableMouseBindings() {","\t// When mouse bindings are disabled, our","\t// touch bindings are enabled.","\tenableTouchBindings();","}","","function startResetTimer() {","\tclearResetTimer();","\tresetTimerID = setTimeout( function() {","\t\tresetTimerID = 0;","\t\tenableMouseBindings();","\t}, $.vmouse.resetTimerDuration );","}","","function clearResetTimer() {","\tif ( resetTimerID ) {","\t\tclearTimeout( resetTimerID );","\t\tresetTimerID = 0;","\t}","}","","function triggerVirtualEvent( eventType, event, flags ) {","\tvar ve;","","\tif ( ( flags && flags[ eventType ] ) ||","\t\t\t\t( !flags && getClosestElementWithVirtualBinding( event.target, eventType ) ) ) {","","\t\tve = createVirtualEvent( event, eventType );","","\t\t$( event.target).trigger( ve );","\t}","","\treturn ve;","}","","function mouseEventCallback( event ) {","\tvar touchID = $.data( event.target, touchTargetPropertyName ),","\t\tve;","","\tif ( !blockMouseTriggers && ( !lastTouchID || lastTouchID !== touchID ) ) {","\t\tve = triggerVirtualEvent( \"v\" + event.type, event );","\t\tif ( ve ) {","\t\t\tif ( ve.isDefaultPrevented() ) {","\t\t\t\tevent.preventDefault();","\t\t\t}","\t\t\tif ( ve.isPropagationStopped() ) {","\t\t\t\tevent.stopPropagation();","\t\t\t}","\t\t\tif ( ve.isImmediatePropagationStopped() ) {","\t\t\t\tevent.stopImmediatePropagation();","\t\t\t}","\t\t}","\t}","}","","function handleTouchStart( event ) {","","\tvar touches = getNativeEvent( event ).touches,","\t\ttarget, flags, t;","","\tif ( touches && touches.length === 1 ) {","","\t\ttarget = event.target;","\t\tflags = getVirtualBindingFlags( target );","","\t\tif ( flags.hasVirtualBinding ) {","","\t\t\tlastTouchID = nextTouchID++;","\t\t\t$.data( target, touchTargetPropertyName, lastTouchID );","","\t\t\tclearResetTimer();","","\t\t\tdisableMouseBindings();","\t\t\tdidScroll = false;","","\t\t\tt = getNativeEvent( event ).touches[ 0 ];","\t\t\tstartX = t.pageX;","\t\t\tstartY = t.pageY;","","\t\t\ttriggerVirtualEvent( \"vmouseover\", event, flags );","\t\t\ttriggerVirtualEvent( \"vmousedown\", event, flags );","\t\t}","\t}","}","","function handleScroll( event ) {","\tif ( blockTouchTriggers ) {","\t\treturn;","\t}","","\tif ( !didScroll ) {","\t\ttriggerVirtualEvent( \"vmousecancel\", event, getVirtualBindingFlags( event.target ) );","\t}","","\tdidScroll = true;","\tstartResetTimer();","}","","function handleTouchMove( event ) {","\tif ( blockTouchTriggers ) {","\t\treturn;","\t}","","\tvar t = getNativeEvent( event ).touches[ 0 ],","\t\tdidCancel = didScroll,","\t\tmoveThreshold = $.vmouse.moveDistanceThreshold,","\t\tflags = getVirtualBindingFlags( event.target );","","\t\tdidScroll = didScroll ||","\t\t\t( Math.abs( t.pageX - startX ) > moveThreshold ||","\t\t\t\tMath.abs( t.pageY - startY ) > moveThreshold );","","\tif ( didScroll && !didCancel ) {","\t\ttriggerVirtualEvent( \"vmousecancel\", event, flags );","\t}","","\ttriggerVirtualEvent( \"vmousemove\", event, flags );","\tstartResetTimer();","}","","function handleTouchEnd( event ) {","\tif ( blockTouchTriggers ) {","\t\treturn;","\t}","","\tdisableTouchBindings();","","\tvar flags = getVirtualBindingFlags( event.target ),","\t\tve, t;","\ttriggerVirtualEvent( \"vmouseup\", event, flags );","","\tif ( !didScroll ) {","\t\tve = triggerVirtualEvent( \"vclick\", event, flags );","\t\tif ( ve && ve.isDefaultPrevented() ) {","\t\t\t// The target of the mouse events that follow the touchend","\t\t\t// event don't necessarily match the target used during the","\t\t\t// touch. This means we need to rely on coordinates for blocking","\t\t\t// any click that is generated.","\t\t\tt = getNativeEvent( event ).changedTouches[ 0 ];","\t\t\tclickBlockList.push({","\t\t\t\ttouchID: lastTouchID,","\t\t\t\tx: t.clientX,","\t\t\t\ty: t.clientY","\t\t\t});","","\t\t\t// Prevent any mouse events that follow from triggering","\t\t\t// virtual event notifications.","\t\t\tblockMouseTriggers = true;","\t\t}","\t}","\ttriggerVirtualEvent( \"vmouseout\", event, flags);","\tdidScroll = false;","","\tstartResetTimer();","}","","function hasVirtualBindings( ele ) {","\tvar bindings = $.data( ele, dataPropertyName ),","\t\tk;","","\tif ( bindings ) {","\t\tfor ( k in bindings ) {","\t\t\tif ( bindings[ k ] ) {","\t\t\t\treturn true;","\t\t\t}","\t\t}","\t}","\treturn false;","}","","function dummyMouseHandler() {}","","function getSpecialEventObject( eventType ) {","\tvar realType = eventType.substr( 1 );","","\treturn {","\t\tsetup: function(/* data, namespace */) {","\t\t\t// If this is the first virtual mouse binding for this element,","\t\t\t// add a bindings object to its data.","","\t\t\tif ( !hasVirtualBindings( this ) ) {","\t\t\t\t$.data( this, dataPropertyName, {} );","\t\t\t}","","\t\t\t// If setup is called, we know it is the first binding for this","\t\t\t// eventType, so initialize the count for the eventType to zero.","\t\t\tvar bindings = $.data( this, dataPropertyName );","\t\t\tbindings[ eventType ] = true;","","\t\t\t// If this is the first virtual mouse event for this type,","\t\t\t// register a global handler on the document.","","\t\t\tactiveDocHandlers[ eventType ] = ( activeDocHandlers[ eventType ] || 0 ) + 1;","","\t\t\tif ( activeDocHandlers[ eventType ] === 1 ) {","\t\t\t\t$document.bind( realType, mouseEventCallback );","\t\t\t}","","\t\t\t// Some browsers, like Opera Mini, won't dispatch mouse/click events","\t\t\t// for elements unless they actually have handlers registered on them.","\t\t\t// To get around this, we register dummy handlers on the elements.","","\t\t\t$( this ).bind( realType, dummyMouseHandler );","","\t\t\t// For now, if event capture is not supported, we rely on mouse handlers.","\t\t\tif ( eventCaptureSupported ) {","\t\t\t\t// If this is the first virtual mouse binding for the document,","\t\t\t\t// register our touchstart handler on the document.","","\t\t\t\tactiveDocHandlers[ \"touchstart\" ] = ( activeDocHandlers[ \"touchstart\" ] || 0) + 1;","","\t\t\t\tif ( activeDocHandlers[ \"touchstart\" ] === 1 ) {","\t\t\t\t\t$document.bind( \"touchstart\", handleTouchStart )","\t\t\t\t\t\t.bind( \"touchend\", handleTouchEnd )","","\t\t\t\t\t\t// On touch platforms, touching the screen and then dragging your finger","\t\t\t\t\t\t// causes the window content to scroll after some distance threshold is","\t\t\t\t\t\t// exceeded. On these platforms, a scroll prevents a click event from being","\t\t\t\t\t\t// dispatched, and on some platforms, even the touchend is suppressed. To","\t\t\t\t\t\t// mimic the suppression of the click event, we need to watch for a scroll","\t\t\t\t\t\t// event. Unfortunately, some platforms like iOS don't dispatch scroll","\t\t\t\t\t\t// events until *AFTER* the user lifts their finger (touchend). This means","\t\t\t\t\t\t// we need to watch both scroll and touchmove events to figure out whether","\t\t\t\t\t\t// or not a scroll happenens before the touchend event is fired.","","\t\t\t\t\t\t.bind( \"touchmove\", handleTouchMove )","\t\t\t\t\t\t.bind( \"scroll\", handleScroll );","\t\t\t\t}","\t\t\t}","\t\t},","","\t\tteardown: function(/* data, namespace */) {","\t\t\t// If this is the last virtual binding for this eventType,","\t\t\t// remove its global handler from the document.","","\t\t\t--activeDocHandlers[ eventType ];","","\t\t\tif ( !activeDocHandlers[ eventType ] ) {","\t\t\t\t$document.unbind( realType, mouseEventCallback );","\t\t\t}","","\t\t\tif ( eventCaptureSupported ) {","\t\t\t\t// If this is the last virtual mouse binding in existence,","\t\t\t\t// remove our document touchstart listener.","","\t\t\t\t--activeDocHandlers[ \"touchstart\" ];","","\t\t\t\tif ( !activeDocHandlers[ \"touchstart\" ] ) {","\t\t\t\t\t$document.unbind( \"touchstart\", handleTouchStart )","\t\t\t\t\t\t.unbind( \"touchmove\", handleTouchMove )","\t\t\t\t\t\t.unbind( \"touchend\", handleTouchEnd )","\t\t\t\t\t\t.unbind( \"scroll\", handleScroll );","\t\t\t\t}","\t\t\t}","","\t\t\tvar $this = $( this ),","\t\t\t\tbindings = $.data( this, dataPropertyName );","","\t\t\t// teardown may be called when an element was","\t\t\t// removed from the DOM. If this is the case,","\t\t\t// jQuery core may have already stripped the element","\t\t\t// of any data bindings so we need to check it before","\t\t\t// using it.","\t\t\tif ( bindings ) {","\t\t\t\tbindings[ eventType ] = false;","\t\t\t}","","\t\t\t// Unregister the dummy event handler.","","\t\t\t$this.unbind( realType, dummyMouseHandler );","","\t\t\t// If this is the last virtual mouse binding on the","\t\t\t// element, remove the binding data from the element.","","\t\t\tif ( !hasVirtualBindings( this ) ) {","\t\t\t\t$this.removeData( dataPropertyName );","\t\t\t}","\t\t}","\t};","}","","// Expose our custom events to the jQuery bind/unbind mechanism.","","for ( i = 0; i < virtualEventNames.length; i++ ) {","\t$.event.special[ virtualEventNames[ i ] ] = getSpecialEventObject( virtualEventNames[ i ] );","}","","// Add a capture click handler to block clicks.","// Note that we require event capture support for this so if the device","// doesn't support it, we punt for now and rely solely on mouse events.","if ( eventCaptureSupported ) {","\tdocument.addEventListener( \"click\", function( e ) {","\t\tvar cnt = clickBlockList.length,","\t\t\ttarget = e.target,","\t\t\tx, y, ele, i, o, touchID;","","\t\tif ( cnt ) {","\t\t\tx = e.clientX;","\t\t\ty = e.clientY;","\t\t\tthreshold = $.vmouse.clickDistanceThreshold;","","\t\t\t// The idea here is to run through the clickBlockList to see if","\t\t\t// the current click event is in the proximity of one of our","\t\t\t// vclick events that had preventDefault() called on it. If we find","\t\t\t// one, then we block the click.","\t\t\t//","\t\t\t// Why do we have to rely on proximity?","\t\t\t//","\t\t\t// Because the target of the touch event that triggered the vclick","\t\t\t// can be different from the target of the click event synthesized","\t\t\t// by the browser. The target of a mouse/click event that is synthesized","\t\t\t// from a touch event seems to be implementation specific. For example,","\t\t\t// some browsers will fire mouse/click events for a link that is near","\t\t\t// a touch event, even though the target of the touchstart/touchend event","\t\t\t// says the user touched outside the link. Also, it seems that with most","\t\t\t// browsers, the target of the mouse/click event is not calculated until the","\t\t\t// time it is dispatched, so if you replace an element that you touched","\t\t\t// with another element, the target of the mouse/click will be the new","\t\t\t// element underneath that point.","\t\t\t//","\t\t\t// Aside from proximity, we also check to see if the target and any","\t\t\t// of its ancestors were the ones that blocked a click. This is necessary","\t\t\t// because of the strange mouse/click target calculation done in the","\t\t\t// Android 2.1 browser, where if you click on an element, and there is a","\t\t\t// mouse/click handler on one of its ancestors, the target will be the","\t\t\t// innermost child of the touched element, even if that child is no where","\t\t\t// near the point of touch.","","\t\t\tele = target;","","\t\t\twhile ( ele ) {","\t\t\t\tfor ( i = 0; i < cnt; i++ ) {","\t\t\t\t\to = clickBlockList[ i ];","\t\t\t\t\ttouchID = 0;","","\t\t\t\t\tif ( ( ele === target && Math.abs( o.x - x ) < threshold && Math.abs( o.y - y ) < threshold ) ||","\t\t\t\t\t\t\t\t$.data( ele, touchTargetPropertyName ) === o.touchID ) {","\t\t\t\t\t\t// XXX: We may want to consider removing matches from the block list","\t\t\t\t\t\t//      instead of waiting for the reset timer to fire.","\t\t\t\t\t\te.preventDefault();","\t\t\t\t\t\te.stopPropagation();","\t\t\t\t\t\treturn;","\t\t\t\t\t}","\t\t\t\t}","\t\t\t\tele = ele.parentNode;","\t\t\t}","\t\t}","\t}, true);","}","})( jQuery, window, document );","","(function( $ ) {","\t$.mobile = {};","}( jQuery ));","","\t(function( $, undefined ) {","\t\tvar support = {","\t\t\ttouch: \"ontouchend\" in document","\t\t};","","\t\t$.mobile.support = $.mobile.support || {};","\t\t$.extend( $.support, support );","\t\t$.extend( $.mobile.support, support );","\t}( jQuery ));","","","(function( $, window, undefined ) {","\tvar $document = $( document ),","\t\tsupportTouch = $.mobile.support.touch,","\t\tscrollEvent = \"touchmove scroll\",","\t\ttouchStartEvent = supportTouch ? \"touchstart\" : \"mousedown\",","\t\ttouchStopEvent = supportTouch ? \"touchend\" : \"mouseup\",","\t\ttouchMoveEvent = supportTouch ? \"touchmove\" : \"mousemove\";","","\t// setup new event shortcuts","\t$.each( ( \"touchstart touchmove touchend \" +","\t\t\"tap taphold \" +","\t\t\"swipe swipeleft swiperight \" +","\t\t\"scrollstart scrollstop\" ).split( \" \" ), function( i, name ) {","","\t\t$.fn[ name ] = function( fn ) {","\t\t\treturn fn ? this.bind( name, fn ) : this.trigger( name );","\t\t};","","\t\t// jQuery < 1.8","\t\tif ( $.attrFn ) {","\t\t\t$.attrFn[ name ] = true;","\t\t}","\t});","","\tfunction triggerCustomEvent( obj, eventType, event, bubble ) {","\t\tvar originalType = event.type;","\t\tevent.type = eventType;","\t\tif ( bubble ) {","\t\t\t$.event.trigger( event, undefined, obj );","\t\t} else {","\t\t\t$.event.dispatch.call( obj, event );","\t\t}","\t\tevent.type = originalType;","\t}","","\t// also handles scrollstop","\t$.event.special.scrollstart = {","","\t\tenabled: true,","\t\tsetup: function() {","","\t\t\tvar thisObject = this,","\t\t\t\t$this = $( thisObject ),","\t\t\t\tscrolling,","\t\t\t\ttimer;","","\t\t\tfunction trigger( event, state ) {","\t\t\t\tscrolling = state;","\t\t\t\ttriggerCustomEvent( thisObject, scrolling ? \"scrollstart\" : \"scrollstop\", event );","\t\t\t}","","\t\t\t// iPhone triggers scroll after a small delay; use touchmove instead","\t\t\t$this.bind( scrollEvent, function( event ) {","","\t\t\t\tif ( !$.event.special.scrollstart.enabled ) {","\t\t\t\t\treturn;","\t\t\t\t}","","\t\t\t\tif ( !scrolling ) {","\t\t\t\t\ttrigger( event, true );","\t\t\t\t}","","\t\t\t\tclearTimeout( timer );","\t\t\t\ttimer = setTimeout( function() {","\t\t\t\t\ttrigger( event, false );","\t\t\t\t}, 50 );","\t\t\t});","\t\t},","\t\tteardown: function() {","\t\t\t$( this ).unbind( scrollEvent );","\t\t}","\t};","","\t// also handles taphold","\t$.event.special.tap = {","\t\ttapholdThreshold: 750,","\t\temitTapOnTaphold: true,","\t\tsetup: function() {","\t\t\tvar thisObject = this,","\t\t\t\t$this = $( thisObject ),","\t\t\t\tisTaphold = false;","","\t\t\t$this.bind( \"vmousedown\", function( event ) {","\t\t\t\tisTaphold = false;","\t\t\t\tif ( event.which && event.which !== 1 ) {","\t\t\t\t\treturn false;","\t\t\t\t}","","\t\t\t\tvar origTarget = event.target,","\t\t\t\t\ttimer;","","\t\t\t\tfunction clearTapTimer() {","\t\t\t\t\tclearTimeout( timer );","\t\t\t\t}","","\t\t\t\tfunction clearTapHandlers() {","\t\t\t\t\tclearTapTimer();","","\t\t\t\t\t$this.unbind( \"vclick\", clickHandler )","\t\t\t\t\t\t.unbind( \"vmouseup\", clearTapTimer );","\t\t\t\t\t$document.unbind( \"vmousecancel\", clearTapHandlers );","\t\t\t\t}","","\t\t\t\tfunction clickHandler( event ) {","\t\t\t\t\tclearTapHandlers();","","\t\t\t\t\t// ONLY trigger a 'tap' event if the start target is","\t\t\t\t\t// the same as the stop target.","\t\t\t\t\tif ( !isTaphold && origTarget === event.target ) {","\t\t\t\t\t\ttriggerCustomEvent( thisObject, \"tap\", event );","\t\t\t\t\t} else if ( isTaphold ) {","\t\t\t\t\t\tevent.preventDefault();","\t\t\t\t\t}","\t\t\t\t}","","\t\t\t\t$this.bind( \"vmouseup\", clearTapTimer )","\t\t\t\t\t.bind( \"vclick\", clickHandler );","\t\t\t\t$document.bind( \"vmousecancel\", clearTapHandlers );","","\t\t\t\ttimer = setTimeout( function() {","\t\t\t\t\tif ( !$.event.special.tap.emitTapOnTaphold ) {","\t\t\t\t\t\tisTaphold = true;","\t\t\t\t\t}","\t\t\t\t\ttriggerCustomEvent( thisObject, \"taphold\", $.Event( \"taphold\", { target: origTarget } ) );","\t\t\t\t}, $.event.special.tap.tapholdThreshold );","\t\t\t});","\t\t},","\t\tteardown: function() {","\t\t\t$( this ).unbind( \"vmousedown\" ).unbind( \"vclick\" ).unbind( \"vmouseup\" );","\t\t\t$document.unbind( \"vmousecancel\" );","\t\t}","\t};","","\t// Also handles swipeleft, swiperight","\t$.event.special.swipe = {","","\t\t// More than this horizontal displacement, and we will suppress scrolling.","\t\tscrollSupressionThreshold: 30,","","\t\t// More time than this, and it isn't a swipe.","\t\tdurationThreshold: 1000,","","\t\t// Swipe horizontal displacement must be more than this.","\t\thorizontalDistanceThreshold: 30,","","\t\t// Swipe vertical displacement must be less than this.","\t\tverticalDistanceThreshold: 30,","","\t\tgetLocation: function ( event ) {","\t\t\tvar winPageX = window.pageXOffset,","\t\t\t\twinPageY = window.pageYOffset,","\t\t\t\tx = event.clientX,","\t\t\t\ty = event.clientY;","","\t\t\tif ( event.pageY === 0 && Math.floor( y ) > Math.floor( event.pageY ) ||","\t\t\t\tevent.pageX === 0 && Math.floor( x ) > Math.floor( event.pageX ) ) {","","\t\t\t\t// iOS4 clientX/clientY have the value that should have been","\t\t\t\t// in pageX/pageY. While pageX/page/ have the value 0","\t\t\t\tx = x - winPageX;","\t\t\t\ty = y - winPageY;","\t\t\t} else if ( y < ( event.pageY - winPageY) || x < ( event.pageX - winPageX ) ) {","","\t\t\t\t// Some Android browsers have totally bogus values for clientX/Y","\t\t\t\t// when scrolling/zooming a page. Detectable since clientX/clientY","\t\t\t\t// should never be smaller than pageX/pageY minus page scroll","\t\t\t\tx = event.pageX - winPageX;","\t\t\t\ty = event.pageY - winPageY;","\t\t\t}","","\t\t\treturn {","\t\t\t\tx: x,","\t\t\t\ty: y","\t\t\t};","\t\t},","","\t\tstart: function( event ) {","\t\t\tvar data = event.originalEvent.touches ?","\t\t\t\t\tevent.originalEvent.touches[ 0 ] : event,","\t\t\t\tlocation = $.event.special.swipe.getLocation( data );","\t\t\treturn {","\t\t\t\t\t\ttime: ( new Date() ).getTime(),","\t\t\t\t\t\tcoords: [ location.x, location.y ],","\t\t\t\t\t\torigin: $( event.target )","\t\t\t\t\t};","\t\t},","","\t\tstop: function( event ) {","\t\t\tvar data = event.originalEvent.touches ?","\t\t\t\t\tevent.originalEvent.touches[ 0 ] : event,","\t\t\t\tlocation = $.event.special.swipe.getLocation( data );","\t\t\treturn {","\t\t\t\t\t\ttime: ( new Date() ).getTime(),","\t\t\t\t\t\tcoords: [ location.x, location.y ]","\t\t\t\t\t};","\t\t},","","\t\thandleSwipe: function( start, stop, thisObject, origTarget ) {","\t\t\tif ( stop.time - start.time < $.event.special.swipe.durationThreshold &&","\t\t\t\tMath.abs( start.coords[ 0 ] - stop.coords[ 0 ] ) > $.event.special.swipe.horizontalDistanceThreshold &&","\t\t\t\tMath.abs( start.coords[ 1 ] - stop.coords[ 1 ] ) < $.event.special.swipe.verticalDistanceThreshold ) {","\t\t\t\tvar direction = start.coords[0] > stop.coords[ 0 ] ? \"swipeleft\" : \"swiperight\";","","\t\t\t\ttriggerCustomEvent( thisObject, \"swipe\", $.Event( \"swipe\", { target: origTarget, swipestart: start, swipestop: stop }), true );","\t\t\t\ttriggerCustomEvent( thisObject, direction,$.Event( direction, { target: origTarget, swipestart: start, swipestop: stop } ), true );","\t\t\t\treturn true;","\t\t\t}","\t\t\treturn false;","","\t\t},","","\t\t// This serves as a flag to ensure that at most one swipe event event is","\t\t// in work at any given time","\t\teventInProgress: false,","","\t\tsetup: function() {","\t\t\tvar events,","\t\t\t\tthisObject = this,","\t\t\t\t$this = $( thisObject ),","\t\t\t\tcontext = {};","","\t\t\t// Retrieve the events data for this element and add the swipe context","\t\t\tevents = $.data( this, \"mobile-events\" );","\t\t\tif ( !events ) {","\t\t\t\tevents = { length: 0 };","\t\t\t\t$.data( this, \"mobile-events\", events );","\t\t\t}","\t\t\tevents.length++;","\t\t\tevents.swipe = context;","","\t\t\tcontext.start = function( event ) {","","\t\t\t\t// Bail if we're already working on a swipe event","\t\t\t\tif ( $.event.special.swipe.eventInProgress ) {","\t\t\t\t\treturn;","\t\t\t\t}","\t\t\t\t$.event.special.swipe.eventInProgress = true;","","\t\t\t\tvar stop,","\t\t\t\t\tstart = $.event.special.swipe.start( event ),","\t\t\t\t\torigTarget = event.target,","\t\t\t\t\temitted = false;","","\t\t\t\tcontext.move = function( event ) {","\t\t\t\t\tif ( !start || event.isDefaultPrevented() ) {","\t\t\t\t\t\treturn;","\t\t\t\t\t}","","\t\t\t\t\tstop = $.event.special.swipe.stop( event );","\t\t\t\t\tif ( !emitted ) {","\t\t\t\t\t\temitted = $.event.special.swipe.handleSwipe( start, stop, thisObject, origTarget );","\t\t\t\t\t\tif ( emitted ) {","","\t\t\t\t\t\t\t// Reset the context to make way for the next swipe event","\t\t\t\t\t\t\t$.event.special.swipe.eventInProgress = false;","\t\t\t\t\t\t}","\t\t\t\t\t}","\t\t\t\t\t// prevent scrolling","\t\t\t\t\tif ( Math.abs( start.coords[ 0 ] - stop.coords[ 0 ] ) > $.event.special.swipe.scrollSupressionThreshold ) {","\t\t\t\t\t\tevent.preventDefault();","\t\t\t\t\t}","\t\t\t\t};","","\t\t\t\tcontext.stop = function() {","\t\t\t\t\t\temitted = true;","","\t\t\t\t\t\t// Reset the context to make way for the next swipe event","\t\t\t\t\t\t$.event.special.swipe.eventInProgress = false;","\t\t\t\t\t\t$document.off( touchMoveEvent, context.move );","\t\t\t\t\t\tcontext.move = null;","\t\t\t\t};","","\t\t\t\t$document.on( touchMoveEvent, context.move )","\t\t\t\t\t.one( touchStopEvent, context.stop );","\t\t\t};","\t\t\t$this.on( touchStartEvent, context.start );","\t\t},","","\t\tteardown: function() {","\t\t\tvar events, context;","","\t\t\tevents = $.data( this, \"mobile-events\" );","\t\t\tif ( events ) {","\t\t\t\tcontext = events.swipe;","\t\t\t\tdelete events.swipe;","\t\t\t\tevents.length--;","\t\t\t\tif ( events.length === 0 ) {","\t\t\t\t\t$.removeData( this, \"mobile-events\" );","\t\t\t\t}","\t\t\t}","","\t\t\tif ( context ) {","\t\t\t\tif ( context.start ) {","\t\t\t\t\t$( this ).off( touchStartEvent, context.start );","\t\t\t\t}","\t\t\t\tif ( context.move ) {","\t\t\t\t\t$document.off( touchMoveEvent, context.move );","\t\t\t\t}","\t\t\t\tif ( context.stop ) {","\t\t\t\t\t$document.off( touchStopEvent, context.stop );","\t\t\t\t}","\t\t\t}","\t\t}","\t};","\t$.each({","\t\tscrollstop: \"scrollstart\",","\t\ttaphold: \"tap\",","\t\tswipeleft: \"swipe.left\",","\t\tswiperight: \"swipe.right\"","\t}, function( event, sourceEvent ) {","","\t\t$.event.special[ event ] = {","\t\t\tsetup: function() {","\t\t\t\t$( this ).bind( sourceEvent, $.noop );","\t\t\t},","\t\t\tteardown: function() {","\t\t\t\t$( this ).unbind( sourceEvent );","\t\t\t}","\t\t};","\t});","","})( jQuery, this );","","","}));"]}]}]]},"ace":{"folds":[],"scrolltop":0,"scrollleft":0,"selection":{"start":{"row":15,"column":19},"end":{"row":15,"column":19},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":0},"timestamp":1429704700451,"hash":"fedcb708bc8930e8e1b7fbad317ac6fafaac8c09"}